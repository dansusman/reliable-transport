#!/usr/bin/python3
#
# CS3700, Fall 2021
# John Henry Rudden, Daniel Susman
# TCP Project Starter Code
#

import datetime
import json
import sys
import socket
import time
import copy

from base64 import b64encode


MSG_SIZE = 1500 # MTU
DATA_SIZE = 1460 
TIMEOUT = 30 # RTO
SEQUENCE = 0 # Sequence number
SEQ_BUFFER = {} # map from sequence number to SeqInfo currently in sliding window
SENT_EVERYTHING = False # have all the data been sent
SLIDING_WINDOW = 20

# Message Fields
SEQ = "sequence"
DATA = "data"
ACK = "ack"
SACK = "sack"
EOF = "eof"

# RTT Estimation
ALPHA = 0.875
MOV_AVG = 500 # current RTT in milliseconds
SEQ = "sequence"

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

time.sleep(.5)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

class SeqInfo:
    duplicate_count = None
    time_stamp = None
    msg = None

    def __init__(self, msg, duplicate_count=0):
        self.time_stamp = get_time()
        self.msg = msg
        self.duplicate_count = duplicate_count

    def build(self, seq_inf):
        return SeqInfo(seq_inf.msg, seq_inf.duplicate_count)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime(
        "%H:%c:%S.%f") + " 3700send: " + string + "\n")

def get_time():
    return int(time.time() * 1000)

def send_next_packet():
    global SEQUENCE
    data = sys.stdin.buffer.read(DATA_SIZE)

    if (len(data) > 0):
        end_of_file = False
        if (len(data) < DATA_SIZE):
            end_of_file = True
        # print(str(b64encode(data)))
        msg = json.dumps({SEQ: SEQUENCE, "data": b64encode(
            data).decode(), "eof": end_of_file, "ack": False})
        SEQ_BUFFER[SEQUENCE] = SeqInfo(msg)
        SEQUENCE += len(data)
        if sock.sendto(msg.encode(), dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
        SEQUENCE += len(data)
        return True
    else:
        return False

def send_packets():
    global SLIDING_WINDOW, SENT_EVERYTHING
    for i in range(SLIDING_WINDOW):
        if not send_next_packet():
            SENT_EVERYTHING = True
            break

def resend_packets():
    """Resends all packets in the current window."""
    for seq_info in SEQ_BUFFER.values():
        built = SeqInfo.build(seq_info)
        sock.sendto(built.msg.encode(), dest)
    
def handle_ack(packet):
    global SEQ_BUFFER, ACKED, SEQ

    ack = packet[ACK]
    seq_n = packet[SEQ]
    if not ack:
        log("error handling ACK from receiver")
        sys.exit(-1) # TODO: maybe broken?

    if seq_n in SEQ_BUFFER:
        update_rtt(packet)
        del SEQ_BUFFER[seq_n]

    if SACK in packet:
        # sack exists on ACK message
        # resend_sack(sack) TODO: performance? burden on network? retransmit single packet
        resend_packets()
        return False
    return True

def update_rtt(packet):
    global SEQ_BUFFER, MOV_AVG, SEQ, ALPHA
    seq_info = SEQ_BUFFER.get(decoded[SEQ])
    sent_time = seq_info.time_stamp
    received_time = get_time()
    sample = received_time - sent_time
    MOV_AVG = ALPHA * MOV_AVG + (1 - ALPHA) * sample 
    log("Update RTT: "  + str(MOV_AVG))

def is_timeout():
    for packet in SEQ_BUFFER:
        if get_time() - packet.time_stamp > 2 * MOV_AVG:
            return True
    return False

def are_duplicates():
    for packet in SEQ_BUFFER:
        if packet.duplicate_count >= 3:
            return True
    return False

# Send first packets
send_packets()

# Now read in data, send packets
while True:
    result = sock.recvfrom(MSG_SIZE)

    if result:
        (data, addr) = result
        try:
            decoded = json.loads(data.decode())
            log("[recv pkt] " + str(decoded))
            log("[recv ack] " + str(decoded['ack']))
            if handle_ack(decoded):
                if are_duplicates or is_timeout:
                    resend_packets()
                else:
                    send_next_packet()

        except (ValueError, KeyError, TypeError) as e:
            log("[recv corrupt packet]")
            raise e

    elif not are_duplicates and not is_timeout:
        # done with everything
        log("No result from recvfrom")
        break

    # elif get_time() - time_since_last_receive > (TIMEOUT * 1000):
    #     log("[error] timeout")
    #     sys.exit(-1)

sys.exit(0)

