#!/usr/bin/python3
#
# CS3700, Fall 2021
# TCP Project Starter Code
#

import datetime
import json
import sys
import socket
import time

from base64 import b64encode

# TODO: should SentEverything be handled in the handling of ACKS

"""
1) TCP Header needs to be made (may change as we build) in JSON form
2) Three way handshake
3) Send Packets and recieve ACKs
4) deal with missing packets (TCP RENO)
5) Congestion Avoidance and Flow Control
"""

MSG_SIZE = 1500 # MTU
DATA_SIZE = 1480 
TIMEOUT = 30 # RTO
RTT = 2 # Round trip time
SEQUENCE = 0 # Sequence number
CONGESTION_WINDOW = 1
MSGS_IN_WINDOW = [] # current batch of packets being sent
ACKED = 0 # number of messages in current window that have been acked
SEQUENCE_STORE = {} # number of duplicate ACKs we have received
SENT_EVERYTHING = False # have all the data been sent

class SeqInfo:
    duplicate_count = 0
    time_stamp = None
    msg = None

    def __init__(self, msg):
        self.time_stamp = datetime.now() * 1000 # in miliseconds
        self.msg = msg


# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

time.sleep(.5)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime(
        "%H:%c:%S.%f") + " 3700send: " + string + "\n")

def send_next_packet():
    global SEQUENCE

    data = sys.stdin.buffer.read(DATA_SIZE)

    if (len(data) > 0):
        end_of_file = False
        if (len(data) < DATA_SIZE):
            end_of_file = True
        # print(str(b64encode(data)))
        msg = json.dumps({"sequence": SEQUENCE, "data": b64encode(
            data).decode(), "eof": end_of_file}) # TODO: may need to have which 
        MSGS_IN_WINDOW.append(msg)
        SEQUENCE_STORE[SEQUENCE] = SeqInfo(msg)
        SEQUENCE += len(data)
        if sock.sendto(msg.encode(), dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
        SEQUENCE += len(data)
        return True
    else:
        return False

def send_packets():
    global CONGESTION_WINDOW, SENT_EVERYTHING
    for i in range(CONGESTION_WINDOW):
        if not send_next_packet():
            SENT_EVERYTHING = True
            break

def resend_packets():
    

def handle_ack(packet):
    global SEQUENCE_STORE, MSGS_IN_WINDOW
    if ack:
        SEQUENCE_STORE.remove(ack.sequenceNumber)

# Send first packet

send_packets()

# Now read in data, send packets
while not SENT_EVERYTHING:
    log("ABOUT TO SLEEP")
    result = sock.recvfrom(MSG_SIZE)

    if result:
        (data, addr) = result
        try:
            decoded = json.loads(data.decode())
            log("[recv pkt] " + str(decoded))
            log("[recv ack] " + str(decoded['ack']))

            if (ACKED == CONGESTION_WINDOW):
                # send next batch

        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")
    else:
        if (are_duplicates() or is_timeout()): # TODO: maybe optimize
            # resend all 

        log("[error] timeout")
        sys.exit(-1)

sock.sendto(json.dumps({"eof": True, "data": "",
            "sequence": SEQUENCE, "ack": False}).encode(), dest)
sys.exit(0)


